# Structure

- **bin**: sandbox - code to test the modules (deliver, network_info, send, setup) and examples.
- **deliver**: in the deliver module you can find the trait `HandleMsg` including the function `handle_msg(&self)` which can be implemented to process incoming messages from the network. Currently the `handle_msg(&self)` function has an implementation for the event FlooodsubMessage and one for GossipsubMessage. For instance, the function is explicitly called in the select-loop in `setup/gossipsub/gossipsub_tokio_setup.rs` or in `setup/floodsub/floodsub_mdns_behaviour.rs`.
- **network_info**: this module contains requests to the Tendermint RPC endpoint in `rpc_net_info.rs` and `rpc_status.rs`. `deserialize.rs` contains all structs to deserialize the json-response from Tendermint. `address_converter.rs` provides functions to convert the listener-address and the peer addresses from the RPC-responses into a Multiaddr format. 
- **send**: contains the function to create an internal channel to submit messages into the select-loop for broadcasting. The returned `UnboundedSender` can be used to add messages to the channel and the `UnboundedReceiver` has to be submitted to the `init`-function, such that it can be included in the select-loop.
- **setup**: contains one module for the network-setup using the floodsub protocol and a module using the gossipsub protocol.  Currently, the `floodsub_tokio_setup.rs` uses the mdns-protocol to discover automatically other peers in the *local* network. This customized network-behaviour is defined in `floodsub_mdns_behaviour.rs`. The `init` function in `floodsub_tokio_setup.rs` requires the arguments *topic* and `UnboundedReceiver`, crates a tokio-based TCP transport, builds a swarm using a random peerId, opens a random listening port and kicks off the select-loop. There are two branches in the select-loop, one for broadcasting messages to the network populated by the `UnboundedReceiver` of the channel and one branch that handles SwarmEvents. The module gossibsub currently contains one implementation with the tokio runtime and one implementation without. The `init` function in `gossipsub_tokio_setup.rs` also requires the arguments *topic* and `UnboundedReceiver` and in addition a listener and and a dial address (as Multiaddr). Then, a tokio-based TCP transport and a swarm using a random peerId are created, the given listening port is openend and the select-loop is kicked off. Again, there are two branches in the select-loop, one to broadcast messages to the network (populated by the internal channel) and another one for handling the SwarmEvents. In contrast to the floodsub implementation there is no customized network-behaviour defined for gossibsub hence, the handling of the (incoming) GossipsubEvent is directly defined inside the select-loop. The incoming messages are there passed to `handle_msg()` (from the trait `HandleMsg`) where they can be further processed.
- **lib.rs**: makes all modules accessible from outside and contains a single utility method to get the rust data type.